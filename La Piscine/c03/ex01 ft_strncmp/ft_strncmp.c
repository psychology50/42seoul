#include <unistd.h>

int	ft_strncmp(char *s1, char *s2, unsigned int n)
{
	unsigned int i;

	if (n == 0)
		return (0);
	i = 0;
	while (s1[i] && (s1[i] == s2[i]) && (i < n - 1))
		i++;
	return (s1[i] - s2[i]);
}

/*
### strncmp

- 대상 문자열 src1 / src2 를 받아서 두 문자열의 일부를 비교하는 함수입니다.
- 문자열 src1과 src2와, int 형식의 n을 받아서 문자열의 처음부터 n만큼 비교합니다.

[참고]

strncmp 함수의 **세번재 매개변수 n에 0을 넣은 경우**에는 **항상 0**이 나오게 됩니다.

strncmp 함수의 세번째 매개변수에 **-1을 넣은 경우**는 **unsigned int 타입에서 언더플로우**가 일어나기 때문에 

최대값이 들어가므로 매개변수로 들어온 문자열을 끝까지 비교를 하게 됩니다.

[디버깅]

1. i < n 을 범위로 했을 경우....
    
    abc, abd, n=2 → `idx`가 2까지 감 → return으로 `(’b’ - ‘b’)`가 아닌 `(’c’ - ‘d’)`가 넘어감.
    
    <해결 방안>
    
      우리가 원하는 비교 범위는 n = 4라고 가정했을 때,  idx 3번까지 해당된다. 
    
    `i < n - 1` 이란 범위를 정해주면 오류가 있을 수 있다고 여겨질 수 있으나, idx 2번까지 무사히 while문이 
    
    작동하여 검사를 마쳤다면...내가 굳이 `s1[3]`과 `s2[3]`의 값이 같다는 걸 확인해야 할 필요가 있을까?
    
    그냥 `i++` 해주고 `n - 1`번 째 값의 차이만 돌려주면 그만인 것이다.
    
      즉, n - 1번 idx를 제외시킨 것이 아니라 n - 1번까지 갔으면 해당 인덱스는 비교해줄 필요가 없기 때문에
    
    바로 차이값만 던져주면 된다는 뜻이 된다.
*/